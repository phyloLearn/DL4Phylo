from math import log2, ceil
import os
from typing import Dict, List, Tuple, Optional

import torch
import numpy as np
from utils import println
from torch.utils.data import Dataset

class TensorDataset(Dataset):
    """A Dataset class to train ML4Phylo networks"""

    def __init__(self, directory: str, filter: Optional[List[str]] = None):
        """Instanciates a TensorDataset

        Parameters
        ----------
        directory : str
            Path to the directory containing .tensor_pair files generated by the
            `make_tensors` script.
        filter: List[str], optional
            List of tensor pair names to keep (useful if you keep training and
            validation tensors in the same directory), default is None

        Returns
        -------
        TensorDataset
            A instance of TensorDataset for training ML4Phylo
        """
        super(TensorDataset, self).__init__()
        self.directory = directory
        self.pairs = [
            filepath
            for filepath in os.listdir(self.directory)
            if filepath.endswith(".tensor_pair")
        ]
        if filter is not None:
            self.pairs = [id for id in self.pairs if id in filter]

    def __len__(self):
        return len(self.pairs)

    def __getitem__(self, index: int):
        pair = torch.load(os.path.join(self.directory, (self.pairs[index])))
        return pair["X"], pair["y"]


def load_typing(path: str) -> Tuple[torch.Tensor, List[str]]:
    """Loads data in typing format into a tensor digestible by the Ml4Phylo network

    Parameters
    ----------
    path : str
        Path to a txt file containing the typing data

    Returns
    -------
    Tuple[torch.Tensor, List[str]]
        a tuple containing:
         - a tensor representing the data (shape encoding_size * seq_len * n_seq)
         - a list of ids of the sequences in the alignment
    """
    tensor_list = []
    parsed = _parse_typing(path)
    encoding_size = 32

    println("Parsed Typing Data:", parsed)
    println("Encoding Size:", encoding_size)

    for sequence in parsed.values():
        """
            Encodes every sequence obtaining a matrix with 2 dimensions (genome_length, encoding_size)
            This matrix stores binary values that represent the codification of each genome identifier.
        """
        encoded_sequence = _binary_encoding(sequence, encoding_size)
        
        println("Encoded Sequence:", encoded_sequence)
        
        # Creates a tensor from the encoded sequence inverting his dimension to (encoding_size, genome_length)
        tensor = torch.from_numpy(encoded_sequence).t()
        
        # Reshapes the tensor to a 3-dimensional one
        reshaped_tensor = tensor.view(encoding_size, 1, -1)
        
        tensor_list.append(reshaped_tensor)
    
    """
        Concats all the tensors present in the list.
        As tensors are made up of 3 dimensions (encoding_size, 1, genome_length), it presents (encoding_size) matrixes.
        After the concatenation the obtained tensor has matrixes with dimension (n_seqs, genome_length), leading to
        a tensor of dimensions (encoding_size, n_seqs, genome_length).
    """
    concated_tensors = torch.cat(tensor_list, dim=1)
    
    """
        Finally, the transpose of the last two dimensions is performed,
        resulting in a tensor of dimensions (encoding_size, genome_length, n_seqs).
    """
    final_tensor = concated_tensors.transpose(-1 , -2)
    
    println("Final Encoded Tensor:", final_tensor.size())
    
    return final_tensor, list(parsed.keys())


def _parse_typing(path: str) -> Dict[str, list]:
    """Parses one txt typing data file and calculates the encoding size

    Parameters
    ----------
    path : str
        Path to .txt typing data file

    Returns
    -------
    Dict[str,str]
        A dictionary with ids as keys and genome identifiers as values
    """
    with open(path, 'r') as f:
        records = f.readlines()[1:]

    rec_dict = {}

    for rec in (record.split() for record in records):
        int_geneId_list = [int(i) for i in rec[1:]]
                
        rec_dict[rec[0]] = int_geneId_list
                    
    return rec_dict


def _binary_encoding(seq: list, encoding_size: int) -> np.ndarray:
    """Encode a sequence with binary encoding

    Parameters
    ----------
    seq : str
        Sequence to encode
        
    encoding_size : int
        Encoded value size

    Returns
    -------
    np.ndarray
        Encoded sequence (shape encoding_size * seq_len)
    """
    return np.array([list('{0:0{1}b}'.format(n, encoding_size)) for n in seq]).astype(int)