import os
from typing import Dict, List, Tuple, Optional

import numpy as np
import torch
from torch.utils.data import Dataset

class TensorDataset(Dataset):
    """A Dataset class to train ML4Phylo networks"""

    def __init__(self, directory: str, filter: Optional[List[str]] = None):
        """Instanciates a TensorDataset

        Parameters
        ----------
        directory : str
            Path to the directory containing .tensor_pair files generated by the
            `make_tensors` script.
        filter: List[str], optional
            List of tensor pair names to keep (useful if you keep training and
            validation tensors in the same directory), default is None

        Returns
        -------
        TensorDataset
            A instance of TensorDataset for training ML4Phylo
        """
        super(TensorDataset, self).__init__()
        self.directory = directory
        self.pairs = [
            filepath
            for filepath in os.listdir(self.directory)
            if filepath.endswith(".tensor_pair")
        ]
        if filter is not None:
            self.pairs = [id for id in self.pairs if id in filter]

    def __len__(self):
        return len(self.pairs)

    def __getitem__(self, index: int):
        pair = torch.load(os.path.join(self.directory, (self.pairs[index])))
        return pair["X"], pair["y"]


def load_typing(path: str) -> Tuple[torch.Tensor, List[str]]:
    """Loads data in typing format into a tensor digestible by the Ml4Phylo network

    Parameters
    ----------
    path : str
        Path to a txt file containing the typing data

    Returns
    -------
    Tuple[torch.Tensor, List[str]]
        a tuple containing:
         - a tensor representing the data (shape 22 * seq_len * n_seq)
         - a list of ids of the sequences in the alignment
    """
    # TODO change this comment above --> last line only
    print("--------------ENCODING--------------")

    # Calculate the maximum number encoding size 
    # TODO - get the maximum number
    encoding_size = 9
    tensor_list = []
    parsed = _parse_typing(path)

    for sequence in parsed.values():
        encoded_sequence = _binary_encoding(sequence, encoding_size)

    print("--------------ENCODING DONE--------------")
    return 


def _parse_typing(path: str) -> Dict[str, str]:
    """Parses one txt typing data file

    Parameters
    ----------
    path : str
        Path to .txt typing data file

    Returns
    -------
    Dict[str,str]
        A dictionnary with ids as keys and typing data as values
    """
    with open(path, 'r') as f:
        records = f.readlines()[1:]

    return {rec[0]: rec[1:] for rec in (record.split() for record in records)}


def _binary_encoding(seq: str, encoding_size: int) -> np.ndarray:
    """Encode a sequence with binary encoding

    Parameters
    ----------
    seq : str
        Sequence to encode
        
    encoding_size : int
        Encoded value size

    Returns
    -------
    np.ndarray
        Encoded sequence (shape encoding_size * seq_len)
    """
    return np.array([int(num) for num in [list('{0:0{1}b}'.format(n, encoding_size)) for n in seq]])